name: Deploy FastAPI to EC2

on:
  push:
    branches:
      - master

env:
  REMOTE_PROJECT_DIR: ${{ secrets.CANAGENT_REMOTE_PATH }}
  STACK_NAME: stack-fastapi
  COMPOSE_FILE: docker-compose.prod.yaml

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect build-impacting changes
        id: detect_changes
        run: |
          set -euo pipefail
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          else
            CHANGED_FILES=$(git ls-tree -r --name-only HEAD)
          fi
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check for Docker/dependency changes (supports any path)
          if echo "$CHANGED_FILES" | grep -Eq '(^|/)(Dockerfile|requirements\.txt)$'; then
            echo "rebuild=full" >> "$GITHUB_OUTPUT"
            echo "üî® FULL REBUILD: Dockerfile or dependencies changed"
          # Check for Python code changes
          elif echo "$CHANGED_FILES" | grep -Eq '\.(py|ini)$'; then
            echo "rebuild=quick" >> "$GITHUB_OUTPUT"
            echo "‚ö° QUICK REBUILD: Python code changed"
          # Check for docker-compose or config changes (no rebuild needed, just restart)
          elif echo "$CHANGED_FILES" | grep -Eq '(docker-compose\.prod\.yaml|\.env)$'; then
            echo "rebuild=none" >> "$GITHUB_OUTPUT"
            echo "üîÑ NO REBUILD: Only runtime config changed (will restart)"
          else
            echo "rebuild=none" >> "$GITHUB_OUTPUT"
            echo "‚úì NO REBUILD: No build-impacting changes"
          fi

      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Deploy stack-fastapi
        env:
          EC2_HOST: ${{ secrets.EC2_IP_ADDRESS }}
          REBUILD_FLAG: ${{ steps.detect_changes.outputs.rebuild }}
        run: |
          set -euo pipefail
          if [ -z "${EC2_HOST:-}" ]; then
            echo "Missing EC2_IP_ADDRESS secret"
            exit 1
          fi

          REMOTE_PATH_VALUE="${REMOTE_PROJECT_DIR:-/home/ubuntu/cannagent}"
          STACK_VALUE="${STACK_NAME:-stack-fastapi}"
          COMPOSE_FILE_VALUE="${COMPOSE_FILE:-docker-compose.prod.yaml}"
          REBUILD_VALUE="${REBUILD_FLAG:-false}"

          ssh -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=60 \
            "ubuntu@${EC2_HOST}" \
            "REMOTE_PROJECT_DIR='${REMOTE_PATH_VALUE}' STACK_NAME='${STACK_VALUE}' COMPOSE_FILE='${COMPOSE_FILE_VALUE}' REBUILD_IMAGES='${REBUILD_VALUE}' bash -s" <<'EOF'
              set -euo pipefail
              REMOTE_PATH="${REMOTE_PROJECT_DIR:-/home/ubuntu/cannagent}"
              STACK="${STACK_NAME:-stack-fastapi}"
              COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.prod.yaml}"

              echo "Using remote path: $REMOTE_PATH"
              cd "$REMOTE_PATH"

              echo "Ensuring git state is clean..."
              git fetch origin master
              git reset --hard origin/master

              echo "Verifying cancon_canna-network exists (should be created by canna project)..."
              if ! docker network inspect cancon_canna-network >/dev/null 2>&1; then
                echo "ERROR: Network cancon_canna-network does not exist. Deploy canna project first."
                exit 1
              fi

              echo "Verifying canna-postgres container is running..."
              if ! docker ps --format '{{.Names}}' | grep -q '^canna-postgres$'; then
                echo "ERROR: canna-postgres container is not running. Deploy canna project first."
                exit 1
              fi

              echo "Extracting database credentials from .env..."
              # Pull DB creds from .env (avoid sourcing entire .env - may contain unquoted spaces)
              POSTGRES_USER_VALUE="${POSTGRES_USER:-postgres}"
              POSTGRES_PASSWORD_VALUE="${POSTGRES_PASSWORD:-}"
              POSTGRES_DB_VALUE="${POSTGRES_DB:-postgres}"
              if [ -f .env ]; then
                env_user=$(sed -n 's/^POSTGRES_USER=//p' .env | tail -n1 | tr -d '"' | xargs)
                env_pass=$(sed -n 's/^POSTGRES_PASSWORD=//p' .env | tail -n1 | tr -d '"' | xargs)
                env_db=$(sed -n 's/^POSTGRES_DB=//p' .env | tail -n1 | tr -d '"' | xargs)
                POSTGRES_USER_VALUE="${env_user:-$POSTGRES_USER_VALUE}"
                POSTGRES_PASSWORD_VALUE="${env_pass:-$POSTGRES_PASSWORD_VALUE}"
                POSTGRES_DB_VALUE="${env_db:-$POSTGRES_DB_VALUE}"
              fi

              echo "Checking database accessibility..."
              # Test database connection (retry up to 5 times)
              DB_READY=false
              for i in {1..5}; do
                if PGPASSWORD="${POSTGRES_PASSWORD_VALUE}" docker exec canna-postgres \
                  psql -U "${POSTGRES_USER_VALUE}" -d "${POSTGRES_DB_VALUE}" -c "SELECT 1" >/dev/null 2>&1; then
                  DB_READY=true
                  echo "‚úÖ Database is accessible"
                  break
                fi
                echo "Database not ready, waiting... (attempt $i/5)"
                sleep 2
              done

              if [ "$DB_READY" = false ]; then
                echo "‚ùå ERROR: Database is not accessible after 5 attempts"
                exit 1
              fi

              echo "Stopping existing stack..."
              # Use explicit container names since docker-compose.prod.yaml uses container_name
              docker stop canagent-api canagent-redis >/dev/null 2>&1 || true
              docker rm canagent-api canagent-redis >/dev/null 2>&1 || true
              echo "‚úì Old containers removed"

              echo "Ensuring pgvector extension is installed..."

              if docker ps --format '{{.Names}}' | grep -q '^canna-postgres$'; then
                docker cp scripts/init_pgvector.sql canna-postgres:/tmp/init_pgvector.sql
                PGPASSWORD="${POSTGRES_PASSWORD_VALUE}" docker exec -e PGPASSWORD canna-postgres \
                  psql -U "${POSTGRES_USER_VALUE}" -d "${POSTGRES_DB_VALUE}" -f /tmp/init_pgvector.sql || \
                  echo "WARNING: pgvector initialization failed; ensure extension is installed in DB image"
              else
                echo "WARNING: canna-postgres container not found; skipped pgvector initialization."
              fi

              # Enable BuildKit for better caching
              export DOCKER_BUILDKIT=1
              export COMPOSE_DOCKER_CLI_BUILD=1

              # Smart 3-tier build strategy
              case "${REBUILD_IMAGES}" in
                "full")
                  echo "üî® FULL REBUILD: Docker/dependency files changed - rebuilding with no cache..."
                  docker-compose -f "$COMPOSE_FILE_PATH" build --no-cache
                  ;;
                "quick")
                  echo "‚ö° QUICK REBUILD: Only code changed - using cached layers..."
                  docker-compose -f "$COMPOSE_FILE_PATH" build --build-arg BUILDKIT_INLINE_CACHE=1
                  ;;
                "none")
                  echo "‚úì NO REBUILD: Using existing images..."
                  # Validate that images exist
                  if ! docker images | grep -q "canagent-api"; then
                    echo "‚ö†Ô∏è  WARNING: canagent-api image not found, forcing rebuild..."
                    docker-compose -f "$COMPOSE_FILE_PATH" build --build-arg BUILDKIT_INLINE_CACHE=1
                  else
                    echo "‚úì Existing image found, skipping build"
                  fi
                  ;;
                *)
                  echo "‚ö†Ô∏è  Unknown rebuild mode: ${REBUILD_IMAGES}, defaulting to quick rebuild..."
                  docker-compose -f "$COMPOSE_FILE_PATH" build --build-arg BUILDKIT_INLINE_CACHE=1
                  ;;
              esac

              # Pre-deployment validation
              echo ""
              echo "=== Pre-Deployment Validation ==="
              echo "Checking built images..."
              docker images | grep -E "(canagent-api|redis)" || echo "‚ö†Ô∏è  WARNING: Expected images not found"

              echo ""
              echo "Checking Docker Compose configuration..."
              docker-compose -f "$COMPOSE_FILE_PATH" config --quiet || {
                echo "‚ùå ERROR: Invalid docker-compose configuration"
                exit 1
              }
              echo "‚úì Configuration valid"
              echo "=== Validation Complete ==="
              echo ""

              # Start Redis first (required for migrations and API startup)
              echo "=== Starting Redis Service ==="
              echo "Starting Redis container..."
              docker-compose -f "$COMPOSE_FILE_PATH" up -d redis

              echo "Waiting for Redis to become healthy..."
              REDIS_READY=false
              for i in {1..30}; do
                REDIS_STATUS=$(docker inspect --format='{{.State.Health.Status}}' canagent-redis 2>/dev/null || echo "missing")
                if [ "$REDIS_STATUS" = "healthy" ]; then
                  REDIS_READY=true
                  echo "‚úÖ Redis is healthy"
                  break
                fi
                echo "[$i/30] Redis status: $REDIS_STATUS, waiting..."
                sleep 2
              done

              if [ "$REDIS_READY" = false ]; then
                echo "‚ùå ERROR: Redis did not become healthy in time"
                docker logs canagent-redis --tail 50
                exit 1
              fi
              echo ""

              echo "=== Applying Database Migrations ==="
              # Run migrations using docker run (not docker-compose run to avoid conflicts)
              set +e  # Temporarily disable exit on error for migration block
              MIGRATION_LOG="/tmp/migration_$$.log"

              # Load environment variables from .env file
              if [ -f .env ]; then
                export $(grep -v '^#' .env | xargs)
              fi

              timeout 120 docker run --rm \
                --network cancon_canna-network \
                --env-file .env \
                -e POSTGRES_HOST=canna-postgres \
                -e REDIS_HOST=canagent-redis \
                canagent-api:latest \
                alembic -c /app/alembic.ini upgrade head > "$MIGRATION_LOG" 2>&1
              MIGRATION_EXIT_CODE=$?
              set -e  # Re-enable exit on error

              if [ $MIGRATION_EXIT_CODE -eq 0 ]; then
                echo "‚úÖ Database migrations applied successfully"
                cat "$MIGRATION_LOG" || echo "No migration output"
              else
                echo ""
                if [ $MIGRATION_EXIT_CODE -eq 124 ]; then
                  echo "‚ùå ERROR: Migration timeout after 120 seconds"
                else
                  echo "‚ùå ERROR: Database migration failed with exit code $MIGRATION_EXIT_CODE"
                fi
                echo "=== Full Migration Output ==="
                cat "$MIGRATION_LOG"
                echo "=== End Migration Output ==="
                echo ""
                echo "‚ö†Ô∏è  Continuing deployment despite migration failure..."
              fi
              rm -f "$MIGRATION_LOG"

              # Note: --rm flag auto-removes the migration container, no manual cleanup needed
              echo "Migration block completed, proceeding to container startup..."

              echo ""
              echo "=== Starting API Service ==="
              echo "Launching API container (Redis already running)..."
              docker-compose -f "$COMPOSE_FILE_PATH" up -d api
              UP_EXIT_CODE=$?

              if [ $UP_EXIT_CODE -ne 0 ]; then
                echo ""
                echo "‚ùå ERROR: docker-compose up -d api failed with exit code: $UP_EXIT_CODE"
                echo ""
                echo "=== Current Container Status ==="
                docker-compose -f "$COMPOSE_FILE_PATH" ps -a
                echo ""
                echo "=== Docker Compose Logs ==="
                docker-compose -f "$COMPOSE_FILE_PATH" logs --tail=50
                echo ""
                echo "=== Available Docker Images ==="
                docker images | grep canagent
                exit 1
              fi

              echo "‚úì API container started successfully"
              echo ""
              echo "Waiting for API to initialize (5 seconds)..."
              sleep 5

              echo "Waiting for containers to start and become healthy..."
              TIMEOUT=150
              ELAPSED=0
              ALL_HEALTHY=false

              while [ $ELAPSED -lt $TIMEOUT ]; do
                # Get container status
                API_STATUS=$(docker inspect --format='{{.State.Status}}' canagent-api 2>/dev/null || echo "missing")
                REDIS_STATUS=$(docker inspect --format='{{.State.Status}}' canagent-redis 2>/dev/null || echo "missing")
                API_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' canagent-api 2>/dev/null || echo "missing")
                REDIS_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' canagent-redis 2>/dev/null || echo "missing")

                echo "[$ELAPSED s] API: $API_STATUS ($API_HEALTH) | Redis: $REDIS_STATUS ($REDIS_HEALTH)"

                # Check if containers are running and healthy
                if [ "$API_STATUS" = "running" ] && [ "$REDIS_STATUS" = "running" ]; then
                  # Wait for healthchecks or accept no-healthcheck as healthy
                  if { [ "$API_HEALTH" = "healthy" ] || [ "$API_HEALTH" = "no-healthcheck" ]; } && \
                     { [ "$REDIS_HEALTH" = "healthy" ] || [ "$REDIS_HEALTH" = "no-healthcheck" ]; }; then
                    ALL_HEALTHY=true
                    break
                  fi
                fi

                # Check if any container is restarting or exited
                if [ "$API_STATUS" = "restarting" ] || [ "$API_STATUS" = "exited" ] || \
                   [ "$REDIS_STATUS" = "restarting" ] || [ "$REDIS_STATUS" = "exited" ]; then
                  echo "ERROR: Container(s) in bad state!"
                  break
                fi

                sleep 5
                ELAPSED=$((ELAPSED + 5))
              done

              echo ""
              echo "=== Final Deployment Status ==="
              echo ""
              echo "Container status:"
              docker-compose -f "$COMPOSE_FILE_PATH" ps
              echo ""
              echo "Network connectivity:"
              docker network inspect cancon_canna-network --format '{{range .Containers}}{{.Name}} {{end}}' || echo "Network inspection failed"

              if [ "$ALL_HEALTHY" = false ]; then
                echo ""
                echo "‚ùå ERROR: Deployment failed - containers did not become healthy within 150 seconds"
                echo ""
                echo "=== API Container Logs (last 100 lines) ==="
                docker logs canagent-api --tail 100 2>&1 || echo "Failed to get API logs"
                echo ""
                echo "=== Redis Container Logs (last 50 lines) ==="
                docker logs canagent-redis --tail 50 2>&1 || echo "Failed to get Redis logs"
                echo ""
                echo "=== Docker Events (last 50) ==="
                docker events --since 2m --until 0s 2>&1 | tail -50 || echo "Failed to get Docker events"
                exit 1
              fi

              echo ""
              echo "‚úÖ SUCCESS: All containers are running and healthy!"
              echo ""
              echo "Deployed services:"
              echo "  ‚Ä¢ API:   http://$(hostname -I | awk '{print $1}'):8000"
              echo "  ‚Ä¢ Redis: Running on internal network"
              echo ""
              echo "Quick health check:"
              docker exec canagent-api python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/api/v1/ping/', timeout=5).read().decode())" 2>/dev/null && echo "‚úÖ API health endpoint responding" || echo "‚ö†Ô∏è  Health endpoint not responding yet"
          EOF
