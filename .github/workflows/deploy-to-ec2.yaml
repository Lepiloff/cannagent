name: Deploy FastAPI to EC2

on:
  push:
    branches:
      - master

env:
  REMOTE_PROJECT_DIR: ${{ secrets.CANAGENT_REMOTE_PATH }}
  STACK_NAME: stack-fastapi
  COMPOSE_FILE: docker-compose.prod.yaml

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect build-impacting changes
        id: detect_changes
        run: |
          set -euo pipefail
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          else
            CHANGED_FILES=$(git ls-tree -r --name-only HEAD)
          fi
          echo "Changed files:"
          echo "$CHANGED_FILES"

          if echo "$CHANGED_FILES" | grep -Eq '^(Dockerfile|requirements\.txt|docker-compose\.prod\.yaml)$'; then
            echo "rebuild=true" >> "$GITHUB_OUTPUT"
          else
            echo "rebuild=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Deploy stack-fastapi
        env:
          EC2_HOST: ${{ secrets.EC2_IP_ADDRESS }}
          REBUILD_FLAG: ${{ steps.detect_changes.outputs.rebuild }}
        run: |
          set -euo pipefail
          if [ -z "${EC2_HOST:-}" ]; then
            echo "Missing EC2_IP_ADDRESS secret"
            exit 1
          fi

          REMOTE_PATH_VALUE="${REMOTE_PROJECT_DIR:-/home/ubuntu/cannagent}"
          STACK_VALUE="${STACK_NAME:-stack-fastapi}"
          COMPOSE_FILE_VALUE="${COMPOSE_FILE:-docker-compose.prod.yaml}"
          REBUILD_VALUE="${REBUILD_FLAG:-false}"

          ssh -o StrictHostKeyChecking=no \
            -o ServerAliveInterval=60 \
            "ubuntu@${EC2_HOST}" \
            "REMOTE_PROJECT_DIR='${REMOTE_PATH_VALUE}' STACK_NAME='${STACK_VALUE}' COMPOSE_FILE='${COMPOSE_FILE_VALUE}' REBUILD_IMAGES='${REBUILD_VALUE}' bash -s" <<'EOF'
              set -euo pipefail
              REMOTE_PATH="${REMOTE_PROJECT_DIR:-/home/ubuntu/cannagent}"
              STACK="${STACK_NAME:-stack-fastapi}"
              COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.prod.yaml}"

              echo "Using remote path: $REMOTE_PATH"
              cd "$REMOTE_PATH"

              echo "Ensuring git state is clean..."
              git fetch origin master
              git reset --hard origin/master

              echo "Verifying cancon_canna-network exists (should be created by canna project)..."
              if ! docker network inspect cancon_canna-network >/dev/null 2>&1; then
                echo "ERROR: Network cancon_canna-network does not exist. Deploy canna project first."
                exit 1
              fi

              echo "Verifying canna-postgres container is running..."
              if ! docker ps --format '{{.Names}}' | grep -q '^canna-postgres$'; then
                echo "ERROR: canna-postgres container is not running. Deploy canna project first."
                exit 1
              fi

              echo "Extracting database credentials from .env..."
              # Pull DB creds from .env (avoid sourcing entire .env - may contain unquoted spaces)
              POSTGRES_USER_VALUE="${POSTGRES_USER:-postgres}"
              POSTGRES_PASSWORD_VALUE="${POSTGRES_PASSWORD:-}"
              POSTGRES_DB_VALUE="${POSTGRES_DB:-postgres}"
              if [ -f .env ]; then
                env_user=$(sed -n 's/^POSTGRES_USER=//p' .env | tail -n1 | tr -d '"' | xargs)
                env_pass=$(sed -n 's/^POSTGRES_PASSWORD=//p' .env | tail -n1 | tr -d '"' | xargs)
                env_db=$(sed -n 's/^POSTGRES_DB=//p' .env | tail -n1 | tr -d '"' | xargs)
                POSTGRES_USER_VALUE="${env_user:-$POSTGRES_USER_VALUE}"
                POSTGRES_PASSWORD_VALUE="${env_pass:-$POSTGRES_PASSWORD_VALUE}"
                POSTGRES_DB_VALUE="${env_db:-$POSTGRES_DB_VALUE}"
              fi

              echo "Checking database accessibility..."
              # Test database connection (retry up to 5 times)
              DB_READY=false
              for i in {1..5}; do
                if PGPASSWORD="${POSTGRES_PASSWORD_VALUE}" docker exec canna-postgres \
                  psql -U "${POSTGRES_USER_VALUE}" -d "${POSTGRES_DB_VALUE}" -c "SELECT 1" >/dev/null 2>&1; then
                  DB_READY=true
                  echo "✅ Database is accessible"
                  break
                fi
                echo "Database not ready, waiting... (attempt $i/5)"
                sleep 2
              done

              if [ "$DB_READY" = false ]; then
                echo "❌ ERROR: Database is not accessible after 5 attempts"
                exit 1
              fi

              export COMPOSE_PROJECT_NAME="$STACK"

              echo "Stopping existing stack..."
              docker-compose -f "$COMPOSE_FILE_PATH" down
              echo "Ensuring old containers are removed (in case of naming conflicts)..."
              docker rm -f canagent-api canagent-redis >/dev/null 2>&1 || true

              echo "Ensuring pgvector extension is installed..."

              if docker ps --format '{{.Names}}' | grep -q '^canna-postgres$'; then
                docker cp scripts/init_pgvector.sql canna-postgres:/tmp/init_pgvector.sql
                PGPASSWORD="${POSTGRES_PASSWORD_VALUE}" docker exec -e PGPASSWORD canna-postgres \
                  psql -U "${POSTGRES_USER_VALUE}" -d "${POSTGRES_DB_VALUE}" -f /tmp/init_pgvector.sql || \
                  echo "WARNING: pgvector initialization failed; ensure extension is installed in DB image"
              else
                echo "WARNING: canna-postgres container not found; skipped pgvector initialization."
              fi

              # Enable BuildKit for better caching
              export DOCKER_BUILDKIT=1
              export COMPOSE_DOCKER_CLI_BUILD=1

              if [ "${REBUILD_IMAGES}" = "true" ]; then
                echo "Docker config or dependencies changed, rebuilding with no cache..."
                docker-compose -f "$COMPOSE_FILE_PATH" build --no-cache
              else
                echo "No Docker config or dependency changes detected; using cached layers..."
                # Use cached layers for faster builds
                docker-compose -f "$COMPOSE_FILE_PATH" build --build-arg BUILDKIT_INLINE_CACHE=1
              fi

              echo "Applying database migrations..."
              # Run migrations with timeout and capture output
              set +e  # Temporarily disable exit on error for migration block
              MIGRATION_LOG="/tmp/migration_$$.log"
              timeout 120 docker-compose -f "$COMPOSE_FILE_PATH" run --rm --no-deps api alembic -c /app/alembic.ini upgrade head > "$MIGRATION_LOG" 2>&1
              MIGRATION_EXIT_CODE=$?
              set -e  # Re-enable exit on error

              if [ $MIGRATION_EXIT_CODE -eq 0 ]; then
                echo "✅ Database migrations applied successfully"
                cat "$MIGRATION_LOG" || echo "No migration output"
              else
                echo ""
                if [ $MIGRATION_EXIT_CODE -eq 124 ]; then
                  echo "❌ ERROR: Migration timeout after 120 seconds"
                else
                  echo "❌ ERROR: Database migration failed with exit code $MIGRATION_EXIT_CODE"
                fi
                echo "=== Full Migration Output ==="
                cat "$MIGRATION_LOG"
                echo "=== End Migration Output ==="
                echo ""
                echo "⚠️  Continuing deployment despite migration failure..."
              fi
              rm -f "$MIGRATION_LOG"

              # Ensure migration container is removed
              docker-compose -f "$COMPOSE_FILE_PATH" rm -f api 2>/dev/null || true

              echo "DEBUG: Migration block completed, proceeding to container startup..."

              echo "Starting updated stack..."
              docker-compose -f "$COMPOSE_FILE_PATH" up -d
              UP_EXIT_CODE=$?
              echo "DEBUG: docker-compose up -d completed with exit code: $UP_EXIT_CODE"

              if [ $UP_EXIT_CODE -ne 0 ]; then
                echo "❌ ERROR: docker-compose up -d failed!"
                docker-compose -f "$COMPOSE_FILE_PATH" ps
                exit 1
              fi

              # Give Docker a moment to start creating containers
              sleep 3

              echo "Waiting for containers to start and become healthy..."
              TIMEOUT=120
              ELAPSED=0
              ALL_HEALTHY=false

              while [ $ELAPSED -lt $TIMEOUT ]; do
                # Get container status
                API_STATUS=$(docker inspect --format='{{.State.Status}}' canagent-api 2>/dev/null || echo "missing")
                REDIS_STATUS=$(docker inspect --format='{{.State.Status}}' canagent-redis 2>/dev/null || echo "missing")
                API_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' canagent-api 2>/dev/null || echo "missing")
                REDIS_HEALTH=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' canagent-redis 2>/dev/null || echo "missing")

                echo "[$ELAPSED s] API: $API_STATUS ($API_HEALTH) | Redis: $REDIS_STATUS ($REDIS_HEALTH)"

                # Check if containers are running and healthy
                if [ "$API_STATUS" = "running" ] && [ "$REDIS_STATUS" = "running" ]; then
                  # Wait for healthchecks or accept no-healthcheck as healthy
                  if { [ "$API_HEALTH" = "healthy" ] || [ "$API_HEALTH" = "no-healthcheck" ]; } && \
                     { [ "$REDIS_HEALTH" = "healthy" ] || [ "$REDIS_HEALTH" = "no-healthcheck" ]; }; then
                    ALL_HEALTHY=true
                    break
                  fi
                fi

                # Check if any container is restarting or exited
                if [ "$API_STATUS" = "restarting" ] || [ "$API_STATUS" = "exited" ] || \
                   [ "$REDIS_STATUS" = "restarting" ] || [ "$REDIS_STATUS" = "exited" ]; then
                  echo "ERROR: Container(s) in bad state!"
                  break
                fi

                sleep 5
                ELAPSED=$((ELAPSED + 5))
              done

              echo ""
              echo "Final container status:"
              docker-compose -f "$COMPOSE_FILE_PATH" ps

              if [ "$ALL_HEALTHY" = false ]; then
                echo ""
                echo "ERROR: Deployment failed - containers did not become healthy within $TIMEOUT seconds"
                echo ""
                echo "=== API Container Logs ==="
                docker logs canagent-api --tail 100 2>&1 || echo "Failed to get API logs"
                echo ""
                echo "=== Redis Container Logs ==="
                docker logs canagent-redis --tail 50 2>&1 || echo "Failed to get Redis logs"
                exit 1
              fi

              echo ""
              echo "SUCCESS: All containers are running and healthy!"
          EOF
